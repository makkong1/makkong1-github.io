# 성능 테스트 및 문제 상황 재현 TODO

> 실제 프로덕션 환경에서 발생할 수 있는 성능 문제, 동시성 문제, 트랜잭션 문제 등을 직접 경험하고 해결하기 위한 작업 목록

---

## 📋 작업 목록

### 1. 대량 데이터 생성 (수만~수십만 건)
**목적**: 대량의 데이터를 생성하여 실제 성능 문제를 재현할 수 있는 환경 구축  
**핵심 체감**: "인덱스 없으면 진짜 느리네..."를 직접 경험

**작업 내용**:
- [ ] 더미 데이터 생성기 클래스 작성 (`DummyDataGenerator.java`)
- [ ] 사용자 10,000명 생성
- [ ] 게시글 100,000개 생성 (또는 1,000,000개)
- [ ] 댓글 1,000,000개 생성
- [ ] 좋아요 500,000개 생성
- [ ] 시간대 분산 (created_at 랜덤 분포)
- [ ] 배치 저장 최적화 (JPA batch_size 설정)
- [ ] 생성 진행 상황 로깅

**대안 방법**:
- [ ] Faker로 CSV 생성 후 `LOAD DATA INFILE`로 직접 삽입
- [ ] MySQL에 직접 100만 건 INSERT 스크립트 작성

**예상 문제점**:
- 인덱스 없이 대량 조회 시 풀 스캔 발생
- 페이징 없이 전체 조회 시 메모리 부족
- N+1 문제로 인한 쿼리 수 폭증
- JOIN 비용 증가

**성능 비교 테스트**:
- [ ] WHERE 조건 인덱스 여부에 따른 쿼리 속도 비교
- [ ] LIKE 검색 성능 비교 (FULLTEXT 인덱스 없음 vs 있음)
- [ ] JOIN 비용 변화 측정
- [ ] 실행 계획(EXPLAIN) 변화 분석

**해결 후 측정 지표**:
- 데이터 생성 소요 시간
- 조회 쿼리 실행 시간 (Before/After)
- EXPLAIN 결과 비교 (풀 스캔 vs 인덱스 스캔)

---

### 2. 동시 요청(Concurrency) 강제 발생
**목적**: Race Condition, 동시 수정 문제를 재현하고 해결 방법 검증  
**핵심 체감**: Lost Update, Phantom Read, Deadlock을 실제로 경험

**작업 내용**:
- [ ] 멀티스레드 테스트 클래스 작성 (`ConcurrencyTest.java`)
- [ ] 부하 테스트 도구 설정 (JMeter 또는 Gatling)
- [ ] 조회수 증가 동시 요청 테스트 (100~500명 동시 요청)
- [ ] 좋아요 동시 클릭 시뮬레이션 (100명이 동시에 좋아요)
- [ ] 하나의 게시물을 100명이 동시에 수정 요청
- [ ] 재고 감소 상황 시뮬레이션 (200명 동시 요청)
- [ ] 댓글 동시 작성 테스트
- [ ] 트랜잭션 경합 재현
- [ ] 동시성 문제 발생 확인 (데이터 불일치)

**예상 문제점**:
- **Lost Update**: 조회수 카운트가 실제보다 적게 저장됨
- **Phantom Read**: 트랜잭션 중 데이터가 사라지거나 나타남
- **Deadlock**: InnoDB 락 기다리다 타임아웃 발생
- 좋아요 수가 정확하지 않음
- 댓글 수가 누락됨

**확인할 내용**:
- [ ] Row Lock 동작 확인
- [ ] Gap Lock 동작 확인
- [ ] Redis 분산락 필요성 체감

**해결 방법**:
- `@Lock(LockModeType.PESSIMISTIC_WRITE)` 적용
- 또는 `UPDATE board SET view_count = view_count + 1 WHERE idx = ?` 직접 SQL 사용
- Redis Redisson 기반 분산락 적용

**해결 후 측정 지표**:
- 동시 요청 처리 시간
- 데이터 정확성 (예상값 vs 실제값)
- Deadlock 발생 횟수

---

### 3. 트랜잭션 문제 직접 만들기
**목적**: 트랜잭션 격리 수준, 락 메커니즘을 이해하고 적용  
**핵심 체감**: "왜 격리 수준이 필요한지", "트랜잭션이 길어지면 왜 안 되는지" 몸으로 깨닫기

**실전 실험**:
- [ ] 트랜잭션 락 테스트 클래스 작성 (`TransactionLockTest.java`)
- [ ] 트랜잭션 A에서 row 수정 → commit 안 함
- [ ] 트랜잭션 B에서 같은 row 수정 시도 → 대기 확인
- [ ] timeout 나거나 deadlock 발생 체험
- [ ] Pessimistic Lock 테스트 (동시 수정 방지)
- [ ] Optimistic Lock 실패 재현 (버전 충돌)
- [ ] 데드락 시나리오 작성 및 재현
- [ ] 순환 참조로 인한 데드락 재현

**트랜잭션 격리 수준 테스트**:
- [ ] READ UNCOMMITTED → Dirty Read 재현
- [ ] READ COMMITTED → Non-repeatable Read 재현
- [ ] REPEATABLE READ → Phantom Read 재현
- [ ] 각 격리 수준별 동작 차이 확인

**테스트 시나리오**:
- 동시에 같은 게시글 수정 시도
- 트랜잭션 A가 읽은 데이터를 트랜잭션 B가 수정
- 서비스 레이어에서 DB 락이 어떻게 작동하는지 확인

**예상 문제점**:
- 낙관적 락 실패 (OptimisticLockException)
- 데드락 발생 (DeadlockLoserDataAccessException)
- Dirty Read로 인한 데이터 불일치
- 트랜잭션이 길어질수록 락 대기 시간 증가

**해결 방법**:
- `@Lock(LockModeType.PESSIMISTIC_WRITE)` 적용
- 트랜잭션 격리 수준 조정
- 데드락 방지를 위한 락 순서 통일
- 트랜잭션 범위 최소화

**해결 후 측정 지표**:
- 동시성 처리 성공률
- 데드락 발생 횟수
- 트랜잭션 처리 시간
- 락 대기 시간

---

### 4. 인덱스 성능 비교 테스트
**목적**: 인덱스의 중요성을 직접 경험하고, 인덱스 설계의 효과를 측정  
**핵심 체감**: "인덱스 없으면 진짜 느리네..."를 직접 체감

**작업 내용**:
- [ ] 성능 테스트 클래스 작성 (`IndexPerformanceTest.java`)
- [ ] 인덱스 제거 후 쿼리 실행 시간 측정
- [ ] 인덱스 추가 후 쿼리 실행 시간 측정
- [ ] EXPLAIN 쿼리 분석 (풀 스캔 vs 인덱스 스캔)
- [ ] 복합 인덱스 효과 측정
- [ ] FULLTEXT 인덱스 성능 비교
- [ ] Before/After 성능 비교 리포트 작성

**테스트 시나리오**:
- 카테고리별 게시글 조회 (인덱스 없음 vs 있음)
- 제목/내용 검색 (FULLTEXT 인덱스 없음 vs 있음)
- 사용자별 게시글 조회
- 날짜 범위 조회
- JOIN 비용 변화 측정

**예상 결과**:
- 인덱스 없음: 풀 스캔으로 수십 초 소요
- 인덱스 있음: 인덱스 스캔으로 밀리초 단위
- 실행 계획(Optimizer) 변화 확인

**해결 후 측정 지표**:
- 쿼리 실행 시간 (Before/After)
- EXPLAIN 결과 비교
- 처리량 (TPS) 비교

---

### 5. Redis 캐싱/분산락 실제 투입
**목적**: Redis를 실제로 활용하여 성능 차이를 체감  
**핵심 체감**: 캐싱 전/후 속도 차이를 눈으로 확인

**작업 내용**:
- [ ] Redis 캐싱 테스트 클래스 작성 (`RedisCacheTest.java`)
- [ ] 인기 게시글 목록 DB 조회 vs Redis 캐싱 조회 비교
- [ ] DB 100만 행 조회 vs Redis 캐싱 조회 성능 비교
- [ ] 좋아요/조회수 증가를 Redis INCR로 병렬 처리
- [ ] 동시성 충돌 시 Redis Redisson 기반 분산락 테스트
- [ ] 캐시 히트율 측정
- [ ] 캐시 미스 시 DB 부하 확인

**테스트 시나리오**:
- 인기 게시글 목록 조회 (DB 직접 조회 vs Redis 캐싱)
- 좋아요 증가 (DB UPDATE vs Redis INCR)
- 분산 환경에서 동시 수정 (분산락 없음 vs 있음)

**예상 결과**:
- DB 직접 조회: 수백 밀리초
- Redis 캐싱 조회: 수 밀리초
- Redis INCR: 동시성 문제 없이 빠른 처리

**해결 후 측정 지표**:
- 조회 응답 시간 (Before/After)
- 캐시 히트율
- 동시성 처리 성공률
- DB 부하 감소율

---

### 6. 웹 서버 부하 증가 시 장애 분석
**목적**: 서버 리소스 한계를 경험하고 병목 지점 파악  
**핵심 체감**: Thread Pool, Connection Pool, GC의 중요성 체감

**작업 내용**:
- [ ] 부하 테스트 클래스 작성 (`ServerLoadTest.java`)
- [ ] Docker로 CPU, RAM 제한 걸기 (예: CPU 0.5 core, RAM 512MB)
- [ ] Nginx Reverse Proxy 붙여서 압력 가하기
- [ ] 무한 루프/지연 API 만들어서 병목 지점 찾기
- [ ] 부하 증가 시 모니터링

**예상 문제점**:
- **Thread Pool exhaustion**: 스레드 풀 고갈
- **DB Connection Pool 고갈**: 커넥션 풀 고갈
- **GC 과다 동작**: 가비지 컬렉션 빈번 발생
- 메모리 부족 (OutOfMemoryError)
- CPU 100% 사용

**확인할 내용**:
- [ ] Thread Pool 사용률 모니터링
- [ ] 커넥션 풀 사용률 모니터링
- [ ] GC 로그 분석
- [ ] 메모리 사용량 추이
- [ ] CPU 사용률 추이

**해결 방법**:
- Thread Pool 크기 조정
- 커넥션 풀 크기 조정
- GC 튜닝
- 리소스 제한 해제 (테스트 후)

**해결 후 측정 지표**:
- Thread Pool 사용률
- 커넥션 풀 사용률
- GC 발생 빈도
- 메모리 사용량
- CPU 사용률
- 응답 시간

---

### 7. 커넥션 풀 고갈 테스트
**목적**: DB 커넥션 풀의 중요성을 이해하고, 고갈 상황을 재현

**작업 내용**:
- [ ] 커넥션 풀 테스트 클래스 작성 (`ConnectionPoolExhaustionTest.java`)
- [ ] application.properties에서 커넥션 풀 크기 1~2개로 제한
- [ ] 동시 요청 코드로 커넥션 고갈 재현
- [ ] 타임아웃 에러 확인
- [ ] 적절한 커넥션 풀 크기 설정
- [ ] 커넥션 풀 모니터링 (HikariCP metrics)

**테스트 시나리오**:
- 커넥션 풀 크기: 2개
- 동시 요청: 10개
- 예상 결과: 8개 요청이 대기 또는 타임아웃

**예상 문제점**:
- `HikariPool - Connection is not available` 에러
- 요청 타임아웃 발생
- 애플리케이션 응답 지연

**해결 방법**:
- 커넥션 풀 크기 조정 (최소 10개 이상)
- 커넥션 타임아웃 설정
- 트랜잭션 범위 최소화

**해결 후 측정 지표**:
- 커넥션 풀 사용률
- 대기 시간
- 타임아웃 발생 횟수

---

### 8. 네트워크 문제 직접 조성하기
**목적**: 실제 네트워크 환경에서의 문제를 경험  
**핵심 체감**: HTTP 타임아웃, 재시도 전략, 커넥션 재사용의 중요성

**작업 내용**:
- [ ] 네트워크 테스트 클래스 작성 (`NetworkIssueTest.java`)
- [ ] `tc` 명령어로 패킷 지연/손실 발생시키기
  - 300ms 지연 시뮬레이션
  - 10% 패킷 드랍 시뮬레이션
- [ ] 서버 두 개 띄워서 latency 차이 확인
- [ ] 파일 업로드/다운로드 시 throughput 변화 관찰
- [ ] 타임아웃 설정 테스트

**테스트 시나리오**:
- 정상 네트워크 vs 지연 네트워크 (300ms)
- 정상 네트워크 vs 패킷 손실 네트워크 (10%)
- 로컬 서버 vs 원격 서버 latency 비교
- 대용량 파일 업로드/다운로드

**예상 문제점**:
- HTTP 타임아웃 발생
- 요청 실패율 증가
- 응답 시간 증가
- 파일 업로드/다운로드 실패

**해결 방법**:
- HTTP 타임아웃 설정 조정
- 재시도 전략 구현
- 커넥션 재사용 (Connection Pool)
- 파일 업로드 청크 단위 처리

**해결 후 측정 지표**:
- 요청 성공률
- 평균 응답 시간
- 타임아웃 발생 횟수
- 파일 전송 속도

---

### 9. 코드 레벨 문제: 스레드·동기화 경험하기
**목적**: 자바 레벨에서 동기화 문제를 직접 경험  
**핵심 체감**: "왜 동기화가 필요한지"를 아키텍처적으로 이해

**작업 내용**:
- [ ] 동기화 테스트 클래스 작성 (`SynchronizationTest.java`)
- [ ] `synchronized` 없이 같은 리스트에 100개 스레드가 add
- [ ] `ConcurrentModificationException` 발생 확인
- [ ] `HashMap`에 100 쓰레드 동시 접근 → 무한 루프 발생
- [ ] `AtomicLong`으로 변경했을 때 해결되는 과정 관찰
- [ ] `ConcurrentHashMap` vs `HashMap` 성능 비교

**테스트 시나리오**:
- ArrayList에 동시 추가 (synchronized 없음)
- HashMap에 동시 접근 (동기화 없음)
- AtomicLong으로 카운터 구현
- ConcurrentHashMap 사용

**예상 문제점**:
- `ConcurrentModificationException` 발생
- `HashMap` 무한 루프 발생
- 데이터 손실
- 스레드 안전성 문제

**해결 방법**:
- `synchronized` 키워드 사용
- `AtomicLong`, `AtomicInteger` 사용
- `ConcurrentHashMap` 사용
- `Collections.synchronizedList()` 사용

**해결 후 측정 지표**:
- 예외 발생 횟수
- 데이터 정확성
- 성능 비교 (동기화 전/후)

---

## 📊 전체 측정 지표

### 성능 지표
- [ ] 쿼리 실행 시간 (Before/After)
- [ ] 동시 요청 처리 시간
- [ ] 메모리 사용량
- [ ] CPU 사용률
- [ ] DB 커넥션 풀 사용률

### 정확성 지표
- [ ] 데이터 일관성 (동시성 테스트)
- [ ] 트랜잭션 성공률
- [ ] 에러 발생률

### 개선 효과
- [ ] 인덱스 적용 전후 성능 비교
- [ ] 락 적용 전후 데이터 정확성 비교
- [ ] 커넥션 풀 크기 조정 전후 처리량 비교

---

## 🛠️ 필요한 설정

### application.properties 추가 설정
```properties
# 배치 처리 최적화
spring.jpa.properties.hibernate.jdbc.batch_size=1000
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# 커넥션 풀 설정 (테스트용)
spring.datasource.hikari.maximum-pool-size=2
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.connection-timeout=3000

# 로깅 설정
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

### 테스트 환경
- [ ] 테스트용 DB 설정 (프로덕션 DB와 분리)
- [ ] 더미 데이터 생성 전 백업
- [ ] 테스트 후 데이터 초기화 스크립트

---

### 10. 실제 장애를 재현하고 해결하는 연습
**목적**: 실제 프로덕션에서 발생할 수 있는 장애를 재현하고 해결  
**핵심 체감**: 장애 대응력을 기르고, 문제 해결 과정을 경험

**장애 재현 시나리오**:

**시나리오 1: MySQL 인덱스 삭제**
- [ ] 인덱스 삭제 후 API 느려짐 확인
- [ ] EXPLAIN으로 풀 스캔 확인
- [ ] 인덱스 재생성 후 성능 회복 확인

**시나리오 2: Redis 다운**
- [ ] Redis 서버 중지
- [ ] 캐시 미스 증가 확인
- [ ] DB 부하 폭발 확인
- [ ] Redis 재시작 후 부하 감소 확인

**시나리오 3: DB Connection Leak**
- [ ] 커넥션을 닫지 않는 코드 작성
- [ ] 30분 뒤 전체 서비스 멈춤 확인
- [ ] 커넥션 풀 고갈 확인
- [ ] 커넥션 누수 수정 후 해결 확인

**시나리오 4: 메시지 큐 메시지 누적**
- [ ] RabbitMQ/Kafka 메시지가 누적되면 소비자 과부하
- [ ] 메시지 처리 속도 < 메시지 생성 속도
- [ ] 메시지 큐 모니터링
- [ ] 소비자 확장 또는 배치 처리로 해결

**장애 대응 프로세스**:
- [ ] 장애 발생 감지 (모니터링)
- [ ] 원인 분석 (로그, 메트릭)
- [ ] 임시 조치 (롤백, 서비스 제한)
- [ ] 근본 원인 해결
- [ ] 재발 방지 대책 수립

**해결 후 측정 지표**:
- 장애 복구 시간
- 서비스 가용성
- 사용자 영향도
- 재발 방지 대책 효과

---

## 📝 참고 사항

1. **권장 순서**: 
   - 더미 데이터 생성 (1) 
   → 동시성 테스트 (2) 
   → 트랜잭션 테스트 (3) 
   → 인덱스 테스트 (4) 
   → Redis 테스트 (5) 
   → 서버 부하 테스트 (6) 
   → 커넥션 풀 테스트 (7) 
   → 네트워크 테스트 (8) 
   → 동기화 테스트 (9) 
   → 장애 재현 (10)

2. **주의사항**: 
   - 프로덕션 DB에 직접 테스트하지 말 것
   - 테스트용 DB를 별도로 구성
   - 테스트 전 데이터 백업 필수

3. **문서화**: 
   - 각 테스트 결과를 문서로 정리하여 포트폴리오에 활용
   - Before/After 비교 리포트 작성
   - 문제 해결 과정 및 인사이트 정리

4. **도구 활용**: 
   - JMeter, Gatling: 부하 테스트
   - VisualVM, JProfiler: JVM 모니터링
   - MySQL Workbench: 쿼리 분석
   - Redis CLI: 캐시 모니터링

---

## ✅ 완료 체크리스트

### 기본 테스트
- [ ] 대량 데이터 생성 완료 (1)
- [ ] 동시성 테스트 완료 (2)
- [ ] 트랜잭션 락 테스트 완료 (3)
- [ ] 인덱스 성능 비교 테스트 완료 (4)
- [ ] Redis 캐싱/분산락 테스트 완료 (5)

### 고급 테스트
- [ ] 웹 서버 부하 테스트 완료 (6)
- [ ] 커넥션 풀 고갈 테스트 완료 (7)
- [ ] 네트워크 문제 테스트 완료 (8)
- [ ] 코드 레벨 동기화 테스트 완료 (9)
- [ ] 실제 장애 재현 및 해결 완료 (10)

### 문서화
- [ ] 전체 측정 지표 수집 완료
- [ ] Before/After 비교 리포트 작성 완료
- [ ] 문제 해결 과정 문서화 완료
- [ ] 포트폴리오용 성과 정리 완료

