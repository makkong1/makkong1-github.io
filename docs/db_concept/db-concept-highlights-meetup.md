# DB 개념 어필 포인트 (SQL 제외)

## 1. N+1 문제 이해 및 해결 전략

### 어필 포인트
- **문제 인식**: 모임 목록 조회 시 각 모임의 organizer를 개별 쿼리로 조회하는 N+1 문제 발견
- **해결 전략**: Fetch Join을 통해 쿼리 수를 75개 → 1개로 감소 (98.7% 개선)
- **DB 관점**: 
  - 데이터베이스 연결 풀 부하 감소
  - 네트워크 라운드트립 최소화
  - DB 서버 부하 분산

### 말할 내용
> "모임 목록 조회 시 N+1 문제를 발견하고 해결한 경험이 있습니다. 74개 모임 조회 시 각 모임의 organizer를 개별 쿼리로 조회하여 총 75개의 쿼리가 발생했는데, 이를 Fetch Join으로 변경하여 1개로 줄였습니다. 이 과정에서 데이터베이스 연결 풀의 부하를 크게 줄이고, 네트워크 라운드트립을 최소화했습니다."

---

## 2. 인덱스 활용 전략

### 어필 포인트
- **인덱스 이해**: `WHERE meetup_idx = ?` 쿼리에서 인덱스 활용
- **복합 인덱스 설계**: 조회 패턴에 맞는 인덱스 설계 고려
- **쿼리 최적화**: Fetch Join 시 인덱스 효율성 이해

### 말할 내용
> "모임 조회 시 인덱스를 효율적으로 활용할 수 있도록 인덱스를 설계했습니다. 특히 Fetch Join을 사용할 때도 인덱스가 효율적으로 작동하도록 조회 패턴을 고려했습니다."

---

## 3. ORM 최적화 (JPA/Hibernate)

### 어필 포인트
- **LAZY/EAGER 로딩 전략**: 필요한 데이터만 로드하는 전략 수립
- **Fetch Join 활용**: `JOIN FETCH`를 사용하여 N+1 문제 해결
- **엔티티 설계**: 연관 관계 설계 시 성능 고려
- **예방적 해결**: 잠재적 N+1 문제를 예방적으로 해결

### 말할 내용
> "JPA의 LAZY 로딩으로 인해 organizer 정보를 각 모임마다 개별 쿼리로 조회하는 문제를 발견했습니다. 이를 해결하기 위해 Fetch Join을 활용하고, 필요한 데이터만 조회하는 Repository 메서드를 설계했습니다. 또한 모임 상세 조회 시 발생할 수 있는 participants N+1 문제를 예방적으로 해결했습니다."

---

## 4. 데이터베이스 연결 풀 관리

### 어필 포인트
- **연결 풀 부하 인식**: N+1 문제로 인한 연결 풀 고갈 위험 이해
- **해결 효과**: 쿼리 수 감소로 연결 풀 사용량 대폭 감소
- **동시성 고려**: 동시 조회 시나리오에서도 안정적인 성능 유지

### 말할 내용
> "N+1 문제로 인해 단일 요청당 75개의 쿼리가 발생하면서 데이터베이스 연결 풀의 부하가 증가했습니다. 이를 1개로 줄임으로써 연결 풀 사용량을 약 98.7% 감소시켰고, 동시 사용자 증가 시에도 안정적인 성능을 유지할 수 있게 되었습니다."

---

## 5. 트랜잭션 관리 및 성능

### 어필 포인트
- **트랜잭션 범위 이해**: Fetch Join은 트랜잭션 내에서 실행되어야 함
- **트랜잭션 격리 수준**: 읽기 작업의 일관성 보장
- **성능 최적화**: 트랜잭션 범위 최소화
- **원자적 UPDATE 쿼리**: Race Condition 해결을 위한 원자적 연산

### 말할 내용
> "Fetch Join을 트랜잭션 내에서 실행하여 데이터 일관성을 보장했습니다. 또한 트랜잭션 범위를 최소화하여 락 경합을 줄이고 성능을 최적화했습니다. Race Condition 해결을 위해 원자적 UPDATE 쿼리를 활용하여 동시성 문제를 해결했습니다."

---

## 6. 쿼리 실행 계획 분석

### 어필 포인트
- **성능 측정**: 실제 운영 환경에서 쿼리 수와 실행 시간 측정
- **실행 시간 분석**: 200ms → 68ms로 개선 (66% 개선)
- **모니터링**: 실제 운영 환경에서의 성능 모니터링 경험

### 말할 내용
> "실제 운영 환경에서 쿼리 실행 수와 실행 시간을 측정하고, 성능 개선 효과를 정량적으로 확인했습니다. 실행 시간을 200ms에서 68ms로 줄여 약 66%의 성능 향상을 달성했습니다."

---

## 7. 데이터베이스 설계 원칙

### 어필 포인트
- **정규화**: 엔티티 간 관계 설계
- **역정규화 고려**: 성능 최적화를 위한 조회 패턴 고려
- **인덱스 설계**: 조회 패턴에 맞는 인덱스 설계
- **DISTINCT 활용**: Fetch Join으로 인한 중복 행 제거

### 말할 내용
> "모임, organizer, participants 간의 관계를 설계할 때, 조회 패턴을 고려하여 인덱스를 설계했습니다. 특히 Fetch Join을 사용할 때 DISTINCT를 활용하여 중복 행을 제거했습니다."

---

## 8. 동시성 제어 (Race Condition 해결)

### 어필 포인트
- **Lost Update 문제 이해**: 동시 참가 시 최대 인원 초과 문제 이해
- **원자적 UPDATE 쿼리**: 조건부 업데이트를 원자적으로 처리
- **DB 제약조건**: CHECK 제약조건을 통한 이중 안전장치
- **트랜잭션 격리 수준**: 동시성 문제 해결을 위한 트랜잭션 관리

### 말할 내용
> "모임 참가 시 동시에 여러 사용자가 참가할 때 Lost Update 문제가 발생하여 최대 인원을 초과하는 문제를 발견했습니다. 이를 해결하기 위해 원자적 UPDATE 쿼리를 활용하여 조건부 업데이트를 DB 레벨에서 원자적으로 처리하도록 했습니다. 또한 CHECK 제약조건을 추가하여 애플리케이션 로직을 우회하는 경우에도 데이터 무결성을 보장했습니다."

---

## 9. 확장성 고려한 설계

### 어필 포인트
- **선형 확장성**: 모임 수가 증가해도 쿼리 수는 일정하게 유지
- **확장성 테스트**: 모임 74개 기준으로 테스트, 1000개여도 동일한 쿼리 수
- **성능 예측**: 데이터 증가에 따른 성능 저하 최소화

### 말할 내용
> "Fetch Join을 적용하여 모임 수가 증가해도 쿼리 수는 일정하게 유지되도록 설계했습니다. 모임 74개든 1000개든 동일하게 1개의 쿼리만 실행되어, 서비스 확장에 유리한 구조를 만들었습니다."

---

## 10. 실제 운영 경험

### 어필 포인트
- **성능 측정**: 실제 운영 환경에서 성능 측정
- **문제 해결 과정**: 문제 발견 → 분석 → 해결 → 검증의 전체 과정
- **문서화**: 트러블슈팅 문서를 통한 지식 공유

### 말할 내용
> "실제 운영 중인 모임 서비스에서 성능 문제를 발견하고, Fetch Join과 원자적 UPDATE 쿼리로 해결했습니다. 전체 과정을 문서화하여 팀 내 지식 공유를 했습니다."

---

## 면접 대답 구성 예시

### 질문: "DB 관련 경험이 있나요?"

**대답 구조:**
1. **문제 발견** (30초)
   - "실제 운영 중인 모임 서비스에서 목록 조회 시 성능 저하를 발견했습니다."
   - "74개 모임 조회 시 총 75개의 쿼리가 발생하고 있었습니다."

2. **원인 분석** (1분)
   - "N+1 문제였습니다. 모임 목록을 조회한 후, 각 모임마다 organizer 정보를 개별 쿼리로 조회하고 있었습니다."
   - "또한 동시 참가 시 Lost Update 문제로 최대 인원을 초과하는 문제도 발생했습니다."

3. **해결 방법** (1분)
   - "Fetch Join을 활용하여 모임과 organizer를 한 번에 조회하도록 변경했습니다."
   - "동시성 문제 해결을 위해 원자적 UPDATE 쿼리를 활용하여 조건부 업데이트를 DB 레벨에서 원자적으로 처리하도록 했습니다."
   - "CHECK 제약조건을 추가하여 데이터 무결성을 보장했습니다."

4. **결과 및 학습** (30초)
   - "쿼리 수를 75개에서 1개로 줄여 98.7% 개선했고, 실행 시간도 200ms에서 68ms로 66% 개선했습니다."
   - "이 과정에서 Fetch Join, 원자적 UPDATE 쿼리, 동시성 제어 등 DB 관련 개념을 깊이 이해하게 되었습니다."

---

## 핵심 키워드

- **N+1 문제 해결**
- **Fetch Join 활용**
- **인덱스 활용**
- **ORM 최적화 (JPA/Hibernate)**
- **데이터베이스 연결 풀 관리**
- **트랜잭션 관리**
- **LAZY/EAGER 로딩 전략**
- **성능 측정 및 모니터링**
- **확장성 고려한 설계**
- **동시성 제어 (Race Condition 해결)**
- **원자적 UPDATE 쿼리**
- **DB 제약조건**
- **실제 운영 경험**

---

## 추가 어필 포인트

### 1. 데이터베이스 성능 모니터링
- 실제 운영 환경에서 쿼리 수 측정
- 쿼리 실행 시간 측정
- 메모리 사용량 측정

### 2. 데이터베이스 설계
- 복합 인덱스 설계
- 조회 패턴 고려한 인덱스 설계
- 엔티티 간 관계 설계
- DB 제약조건을 통한 데이터 무결성 보장

### 3. 문제 해결 프로세스
- 문제 발견 → 분석 → 해결 → 검증
- 정량적 측정을 통한 검증
- 문서화를 통한 지식 공유

### 4. 동시성 제어
- Lost Update 문제 이해
- 원자적 UPDATE 쿼리를 통한 동시성 문제 해결
- DB 제약조건을 통한 이중 안전장치
