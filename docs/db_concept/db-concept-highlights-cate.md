# DB 개념 어필 포인트 (SQL 제외)

## 1. N+1 문제 이해 및 해결 전략

### 어필 포인트
- **문제 인식**: 펫케어 요청 목록 조회 시 CareApplication, File, PetVaccination을 각각 개별 쿼리로 조회하는 N+1 문제 발견
- **해결 전략**: 배치 조회 패턴과 Fetch Join을 통해 쿼리 수를 약 2400개 → 4-5개로 감소 (99.8% 개선)
- **DB 관점**: 
  - 데이터베이스 연결 풀 부하 감소
  - 네트워크 라운드트립 최소화
  - DB 서버 부하 분산

### 말할 내용
> "펫케어 요청 목록 조회 시 N+1 문제를 발견하고 해결한 경험이 있습니다. 1004개 요청 조회 시 CareApplication, File, PetVaccination을 각각 개별 쿼리로 조회하여 총 약 2400개의 쿼리가 발생했는데, 이를 배치 조회 패턴과 Fetch Join으로 변경하여 4-5개로 줄였습니다. 이 과정에서 데이터베이스 연결 풀의 부하를 크게 줄이고, 네트워크 라운드트립을 최소화했습니다."

---

## 2. 인덱스 활용 전략

### 어필 포인트
- **인덱스 이해**: `WHERE care_request_idx IN (...)` 쿼리에서 인덱스 활용
- **복합 인덱스 설계**: `(care_request_idx, status)` 같은 복합 인덱스 고려
- **쿼리 최적화**: IN 절을 사용한 배치 조회 시 인덱스 효율성 이해
- **@BatchSize 활용**: Hibernate의 @BatchSize를 활용한 중첩 컬렉션 최적화

### 말할 내용
> "배치 조회를 위해 IN 절을 사용할 때, 데이터베이스가 인덱스를 효율적으로 활용할 수 있도록 복합 인덱스를 설계했습니다. CareApplication 조회를 위한 `(care_request_idx, status)` 복합 인덱스를 통해 조회 성능을 향상시켰습니다. 또한 Hibernate의 @BatchSize를 활용하여 중첩 컬렉션(PetVaccination) 조회를 최적화했습니다."

---

## 3. ORM 최적화 (JPA/Hibernate)

### 어필 포인트
- **LAZY/EAGER 로딩 전략**: 필요한 데이터만 로드하는 전략 수립
- **Fetch Join 활용**: `JOIN FETCH`를 사용하여 N+1 문제 해결
- **엔티티 설계**: 연관 관계 설계 시 성능 고려
- **@BatchSize 활용**: 중첩 컬렉션 조회 시 배치 크기 제어

### 말할 내용
> "JPA의 LAZY 로딩으로 인해 CareApplication, File, PetVaccination을 각각 개별 쿼리로 조회하는 문제를 발견했습니다. 이를 해결하기 위해 Fetch Join을 활용하고, 필요한 데이터만 조회하는 Repository 메서드를 설계했습니다. 또한 @BatchSize를 활용하여 중첩 컬렉션 조회를 최적화했습니다."

---

## 4. 데이터베이스 연결 풀 관리

### 어필 포인트
- **연결 풀 부하 인식**: N+1 문제로 인한 연결 풀 고갈 위험 이해
- **해결 효과**: 쿼리 수 감소로 연결 풀 사용량 대폭 감소
- **동시성 고려**: 동시 조회 시나리오에서도 안정적인 성능 유지

### 말할 내용
> "N+1 문제로 인해 단일 요청당 약 2400개의 쿼리가 발생하면서 데이터베이스 연결 풀의 부하가 증가했습니다. 이를 4-5개로 줄임으로써 연결 풀 사용량을 약 99.8% 감소시켰고, 동시 사용자 증가 시에도 안정적인 성능을 유지할 수 있게 되었습니다."

---

## 5. 트랜잭션 관리 및 성능

### 어필 포인트
- **트랜잭션 범위 이해**: 배치 조회는 트랜잭션 내에서 실행되어야 함
- **트랜잭션 격리 수준**: 읽기 작업의 일관성 보장
- **성능 최적화**: 트랜잭션 범위 최소화
- **비관적 락**: Race Condition 해결을 위한 비관적 락 활용

### 말할 내용
> "배치 조회를 트랜잭션 내에서 실행하여 데이터 일관성을 보장했습니다. 또한 트랜잭션 범위를 최소화하여 락 경합을 줄이고 성능을 최적화했습니다. Race Condition 해결을 위해 비관적 락(PESSIMISTIC_WRITE)을 활용하여 동시성 문제를 해결했습니다."

---

## 6. 쿼리 실행 계획 분석

### 어필 포인트
- **성능 측정**: 실제 운영 환경에서 쿼리 수와 실행 시간 측정
- **실행 시간 분석**: 1084ms → 66ms로 개선 (94% 개선)
- **모니터링**: 실제 운영 환경에서의 성능 모니터링 경험

### 말할 내용
> "실제 운영 환경에서 쿼리 실행 수와 실행 시간을 측정하고, 성능 개선 효과를 정량적으로 확인했습니다. 실행 시간을 1084ms에서 66ms로 줄여 약 16배의 성능 향상을 달성했습니다."

---

## 7. 데이터베이스 설계 원칙

### 어필 포인트
- **정규화**: 엔티티 간 관계 설계
- **역정규화 고려**: 성능 최적화를 위한 조회 패턴 고려
- **인덱스 설계**: 조회 패턴에 맞는 인덱스 설계
- **DISTINCT 활용**: Fetch Join으로 인한 중복 행 제거

### 말할 내용
> "CareRequest, CareApplication, Pet, PetVaccination 간의 관계를 설계할 때, 조회 패턴을 고려하여 인덱스를 설계했습니다. 특히 배치 조회를 위한 복합 인덱스를 설계하여 조회 성능을 최적화했습니다. 또한 Fetch Join으로 인한 중복 행을 DISTINCT로 제거했습니다."

---

## 8. 메모리 관리 및 GC 최적화

### 어필 포인트
- **메모리 사용량 측정**: 21MB → 6MB (71% 감소)
- **불필요한 데이터 로드 방지**: 필요한 데이터만 조회
- **GC 부하 감소**: 메모리 사용량 감소로 GC 부하 감소

### 말할 내용
> "LAZY 로딩으로 인해 불필요한 데이터가 메모리에 로드되는 문제를 발견하고, 필요한 데이터만 조회하도록 최적화했습니다. 이를 통해 메모리 사용량을 71% 감소시켰고, GC 부하를 줄여 서버 안정성을 향상시켰습니다."

---

## 9. 확장성 고려한 설계

### 어필 포인트
- **선형 확장성**: 요청 수가 증가해도 쿼리 수는 일정하게 유지
- **확장성 테스트**: 요청 1004개 기준으로 테스트, 10000개여도 동일한 쿼리 수
- **성능 예측**: 데이터 증가에 따른 성능 저하 최소화

### 말할 내용
> "배치 조회 패턴을 적용하여 요청 수가 증가해도 쿼리 수는 일정하게 유지되도록 설계했습니다. 요청 1004개든 10000개든 동일하게 4-5개의 쿼리만 실행되어, 서비스 확장에 유리한 구조를 만들었습니다."

---

## 10. 동시성 제어 (Race Condition 해결)

### 어필 포인트
- **트랜잭션 격리 수준 이해**: REPEATABLE READ에서 발생하는 동시성 문제 이해
- **비관적 락 활용**: PESSIMISTIC_WRITE 락을 통한 순차 처리 보장
- **Check-Then-Act 패턴**: 동시성 문제가 발생하는 패턴 인식 및 해결
- **영속성 컨텍스트 관리**: saveAndFlush를 통한 즉시 반영

### 말할 내용
> "펫케어 거래 확정 시 두 사용자가 동시에 버튼을 눌렀을 때 Race Condition이 발생하는 문제를 발견했습니다. 트랜잭션 격리 수준(REPEATABLE READ)으로 인해 상대방의 변경사항을 읽지 못해 후속 처리가 실행되지 않는 문제였습니다. 이를 해결하기 위해 비관적 락(PESSIMISTIC_WRITE)을 활용하여 순차 처리를 보장하고, saveAndFlush를 통해 즉시 DB에 반영하도록 했습니다."

---

## 11. 실제 운영 경험

### 어필 포인트
- **성능 측정**: 실제 운영 환경에서 성능 측정
- **문제 해결 과정**: 문제 발견 → 분석 → 해결 → 검증의 전체 과정
- **문서화**: 트러블슈팅 문서를 통한 지식 공유

### 말할 내용
> "실제 운영 중인 서비스에서 성능 문제를 발견하고, 정량적으로 측정한 후, 배치 조회 패턴과 Fetch Join으로 해결했습니다. 또한 Race Condition 문제를 해결하기 위해 비관적 락을 활용하여 동시성 문제를 해결했습니다. 전체 과정을 문서화하여 팀 내 지식 공유를 했습니다."

---

## 면접 대답 구성 예시

### 질문: "DB 관련 경험이 있나요?"

**대답 구조:**
1. **문제 발견** (30초)
   - "실제 운영 중인 펫케어 서비스에서 요청 목록 조회 시 성능 저하를 발견했습니다."
   - "실제 측정 결과 약 2400개의 쿼리가 발생하고 있었습니다."

2. **원인 분석** (1분)
   - "N+1 문제였습니다. 요청 목록을 조회한 후, 각 요청마다 CareApplication, File, PetVaccination을 개별 쿼리로 조회하고 있었습니다."
   - "또한 LAZY 로딩으로 인해 필요한 데이터만 필요한데 모든 연관 데이터를 메모리에 로드하고 있었습니다."

3. **해결 방법** (1분)
   - "배치 조회 패턴을 적용했습니다. 요청 ID 목록을 추출한 후, IN 절을 사용하여 한 번에 조회하도록 변경했습니다."
   - "Fetch Join을 활용하여 CareApplication도 함께 조회하여 추가 쿼리를 방지했습니다."
   - "@BatchSize를 활용하여 중첩 컬렉션(PetVaccination) 조회를 최적화했습니다."

4. **결과 및 학습** (30초)
   - "쿼리 수를 약 2400개에서 4-5개로 줄여 99.8% 개선했고, 실행 시간도 1084ms에서 66ms로 94% 개선했습니다."
   - "이 과정에서 데이터베이스 연결 풀 관리, 인덱스 활용, ORM 최적화, 동시성 제어 등 DB 관련 개념을 깊이 이해하게 되었습니다."

---

## 핵심 키워드

- **N+1 문제 해결**
- **배치 조회 패턴**
- **인덱스 활용**
- **ORM 최적화 (JPA/Hibernate)**
- **데이터베이스 연결 풀 관리**
- **트랜잭션 관리**
- **LAZY/EAGER 로딩 전략**
- **성능 측정 및 모니터링**
- **확장성 고려한 설계**
- **동시성 제어 (Race Condition 해결)**
- **비관적 락 (PESSIMISTIC_WRITE)**
- **실제 운영 경험**

---

## 추가 어필 포인트

### 1. 데이터베이스 성능 모니터링
- 실제 운영 환경에서 쿼리 수 측정
- 쿼리 실행 시간 측정
- 메모리 사용량 측정

### 2. 데이터베이스 설계
- 복합 인덱스 설계
- 조회 패턴 고려한 인덱스 설계
- 엔티티 간 관계 설계
- @BatchSize를 활용한 중첩 컬렉션 최적화

### 3. 문제 해결 프로세스
- 문제 발견 → 분석 → 해결 → 검증
- 정량적 측정을 통한 검증
- 문서화를 통한 지식 공유

### 4. 동시성 제어
- 트랜잭션 격리 수준 이해
- 비관적 락을 통한 동시성 문제 해결
- Check-Then-Act 패턴 인식 및 해결
