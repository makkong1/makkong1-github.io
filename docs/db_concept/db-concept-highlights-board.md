# DB 개념 어필 포인트 (SQL 제외)

## 1. N+1 문제 이해 및 해결 전략

### 어필 포인트
- **문제 인식**: 게시글 목록 조회 시 작성자, 반응, 첨부파일 정보를 각각 개별 쿼리로 조회하는 N+1 문제 발견
- **해결 전략**: 배치 조회 패턴과 Fetch Join을 통해 쿼리 수를 301개 → 3개로 감소 (99% 개선)
- **DB 관점**: 
  - 데이터베이스 연결 풀 부하 감소
  - 네트워크 라운드트립 최소화
  - DB 서버 부하 분산

### 말할 내용
> "게시글 목록 조회 시 N+1 문제를 발견하고 해결한 경험이 있습니다. 100개 게시글 조회 시 작성자, 반응, 첨부파일 정보를 각각 개별 쿼리로 조회하여 총 301개의 쿼리가 발생했는데, 이를 배치 조회 패턴과 Fetch Join으로 변경하여 3개로 줄였습니다. 이 과정에서 데이터베이스 연결 풀의 부하를 크게 줄이고, 네트워크 라운드트립을 최소화했습니다."

---

## 2. 인덱스 활용 전략

### 어필 포인트
- **인덱스 이해**: `WHERE board_idx IN (...)` 쿼리에서 인덱스 활용
- **복합 인덱스 설계**: `(board_idx, reaction_type)`, `(board_idx, is_deleted, created_at)` 같은 복합 인덱스 고려
- **쿼리 최적화**: IN 절을 사용한 배치 조회 시 인덱스 효율성 이해
- **FULLTEXT 인덱스**: MySQL FULLTEXT 인덱스(ngram 파서)를 활용한 한글 검색 최적화

### 말할 내용
> "배치 조회를 위해 IN 절을 사용할 때, 데이터베이스가 인덱스를 효율적으로 활용할 수 있도록 복합 인덱스를 설계했습니다. 반응 정보 조회를 위한 `(board_idx, reaction_type)` 복합 인덱스와 댓글 조회를 위한 `(board_idx, is_deleted, created_at)` 복합 인덱스를 통해 조회 성능을 향상시켰습니다. 또한 한글 검색을 위해 MySQL FULLTEXT 인덱스(ngram 파서)를 활용하여 LIKE 검색 대비 10배 이상의 성능 향상을 달성했습니다."

---

## 3. ORM 최적화 (JPA/Hibernate)

### 어필 포인트
- **LAZY/EAGER 로딩 전략**: 필요한 데이터만 로드하는 전략 수립
- **Fetch Join 활용**: `JOIN FETCH`를 사용하여 N+1 문제 해결
- **엔티티 설계**: 연관 관계 설계 시 성능 고려
- **DISTINCT 활용**: Fetch Join으로 인한 중복 행 제거

### 말할 내용
> "JPA의 LAZY 로딩으로 인해 작성자 정보를 각 게시글마다 개별 쿼리로 조회하는 문제를 발견했습니다. 이를 해결하기 위해 Fetch Join을 활용하고, 필요한 데이터만 조회하는 Repository 메서드를 설계했습니다. 또한 연관 엔티티를 함께 조회하여 추가 쿼리를 방지했고, DISTINCT를 사용하여 중복 행을 제거했습니다."

---

## 4. 데이터베이스 연결 풀 관리

### 어필 포인트
- **연결 풀 부하 인식**: N+1 문제로 인한 연결 풀 고갈 위험 이해
- **해결 효과**: 쿼리 수 감소로 연결 풀 사용량 대폭 감소
- **동시성 고려**: 동시 조회 시나리오에서도 안정적인 성능 유지

### 말할 내용
> "N+1 문제로 인해 단일 요청당 301개의 쿼리가 발생하면서 데이터베이스 연결 풀의 부하가 증가했습니다. 이를 3개로 줄임으로써 연결 풀 사용량을 약 99% 감소시켰고, 동시 사용자 증가 시에도 안정적인 성능을 유지할 수 있게 되었습니다."

---

## 5. 트랜잭션 관리 및 성능

### 어필 포인트
- **트랜잭션 범위 이해**: 배치 조회는 트랜잭션 내에서 실행되어야 함
- **트랜잭션 격리 수준**: 읽기 작업의 일관성 보장
- **성능 최적화**: 트랜잭션 범위 최소화

### 말할 내용
> "배치 조회를 트랜잭션 내에서 실행하여 데이터 일관성을 보장했습니다. 또한 트랜잭션 범위를 최소화하여 락 경합을 줄이고 성능을 최적화했습니다."

---

## 6. 쿼리 실행 계획 분석

### 어필 포인트
- **성능 측정**: Hibernate Statistics를 활용한 쿼리 수 측정
- **실행 시간 분석**: 745ms → 30ms로 개선 (96% 개선)
- **모니터링**: 실제 운영 환경에서의 성능 모니터링 경험

### 말할 내용
> "Hibernate Statistics를 활용하여 실제 쿼리 실행 수를 측정하고, 성능 개선 효과를 정량적으로 확인했습니다. 실행 시간을 745ms에서 30ms로 줄여 약 24배의 성능 향상을 달성했습니다."

---

## 7. 데이터베이스 설계 원칙

### 어필 포인트
- **정규화**: 엔티티 간 관계 설계
- **역정규화 고려**: 성능 최적화를 위한 조회 패턴 고려
- **인덱스 설계**: 조회 패턴에 맞는 인덱스 설계
- **스냅샷 패턴**: 인기글 스냅샷 생성으로 복잡한 계산 최적화

### 말할 내용
> "게시글, 작성자, 반응, 첨부파일 간의 관계를 설계할 때, 조회 패턴을 고려하여 인덱스를 설계했습니다. 특히 배치 조회를 위한 복합 인덱스를 설계하여 조회 성능을 최적화했습니다. 또한 인기글 조회 시마다 복잡한 인기도 점수 계산을 수행하는 대신, 스케줄러를 통해 스냅샷을 미리 생성하여 저장함으로써 실시간 계산 없이 즉시 조회할 수 있도록 최적화했습니다."

---

## 8. 메모리 관리 및 GC 최적화

### 어필 포인트
- **메모리 사용량 측정**: 22.50 MB → 2 MB (91% 감소)
- **불필요한 데이터 로드 방지**: 필요한 데이터만 조회
- **GC 부하 감소**: 메모리 사용량 감소로 GC 부하 감소

### 말할 내용
> "LAZY 로딩으로 인해 불필요한 데이터가 메모리에 로드되는 문제를 발견하고, 필요한 데이터만 조회하도록 최적화했습니다. 이를 통해 메모리 사용량을 91% 감소시켰고, GC 부하를 줄여 서버 안정성을 향상시켰습니다."

---

## 9. 확장성 고려한 설계

### 어필 포인트
- **선형 확장성**: 게시글 수가 증가해도 쿼리 수는 일정하게 유지
- **확장성 테스트**: 게시글 100개 기준으로 테스트, 1000개여도 동일한 쿼리 수
- **성능 예측**: 데이터 증가에 따른 성능 저하 최소화

### 말할 내용
> "배치 조회 패턴을 적용하여 게시글 수가 증가해도 쿼리 수는 일정하게 유지되도록 설계했습니다. 게시글 100개든 1000개든 동일하게 3개의 쿼리만 실행되어, 서비스 확장에 유리한 구조를 만들었습니다."

---

## 10. 실제 운영 경험

### 어필 포인트
- **성능 측정**: 실제 테스트 환경에서 성능 측정
- **문제 해결 과정**: 문제 발견 → 분석 → 해결 → 검증의 전체 과정
- **문서화**: 트러블슈팅 문서를 통한 지식 공유

### 말할 내용
> "실제 운영 중인 서비스에서 성능 문제를 발견하고, Hibernate Statistics를 활용하여 정량적으로 측정한 후, 배치 조회 패턴과 Fetch Join으로 해결했습니다. 또한 전체 과정을 문서화하여 팀 내 지식 공유를 했습니다."

---

## 면접 대답 구성 예시

### 질문: "DB 관련 경험이 있나요?"

**대답 구조:**
1. **문제 발견** (30초)
   - "실제 운영 중인 게시판 서비스에서 게시글 목록 조회 시 성능 저하를 발견했습니다."
   - "Hibernate Statistics로 측정한 결과 301개의 쿼리가 발생하고 있었습니다."

2. **원인 분석** (1분)
   - "N+1 문제였습니다. 게시글 목록을 조회한 후, 각 게시글마다 작성자 정보, 반응 정보, 첨부파일을 개별 쿼리로 조회하고 있었습니다."
   - "또한 LAZY 로딩으로 인해 필요한 데이터만 필요한데 모든 연관 데이터를 메모리에 로드하고 있었습니다."

3. **해결 방법** (1분)
   - "배치 조회 패턴을 적용했습니다. 게시글 ID 목록을 추출한 후, IN 절을 사용하여 한 번에 조회하도록 변경했습니다."
   - "Fetch Join을 활용하여 작성자 정보도 함께 조회하여 추가 쿼리를 방지했습니다."
   - "복합 인덱스를 설계하여 배치 조회 시 인덱스를 효율적으로 활용하도록 했습니다."

4. **결과 및 학습** (30초)
   - "쿼리 수를 301개에서 3개로 줄여 99% 개선했고, 실행 시간도 745ms에서 30ms로 96% 개선했습니다."
   - "이 과정에서 데이터베이스 연결 풀 관리, 인덱스 활용, ORM 최적화 등 DB 관련 개념을 깊이 이해하게 되었습니다."

---

## 핵심 키워드

- **N+1 문제 해결**
- **배치 조회 패턴**
- **인덱스 활용 (복합 인덱스, FULLTEXT 인덱스)**
- **ORM 최적화 (JPA/Hibernate)**
- **데이터베이스 연결 풀 관리**
- **트랜잭션 관리**
- **LAZY/EAGER 로딩 전략**
- **성능 측정 및 모니터링**
- **확장성 고려한 설계**
- **실제 운영 경험**
- **스냅샷 패턴**

---

## 추가 어필 포인트

### 1. 데이터베이스 성능 모니터링
- Hibernate Statistics 활용
- 쿼리 실행 시간 측정
- 메모리 사용량 측정

### 2. 데이터베이스 설계
- 복합 인덱스 설계
- 조회 패턴 고려한 인덱스 설계
- 엔티티 간 관계 설계
- FULLTEXT 인덱스를 활용한 검색 최적화

### 3. 문제 해결 프로세스
- 문제 발견 → 분석 → 해결 → 검증
- 정량적 측정을 통한 검증
- 문서화를 통한 지식 공유

### 4. 성능 최적화 패턴
- 스냅샷 패턴을 통한 복잡한 계산 최적화
- 배치 조회를 통한 쿼리 수 감소
- Fetch Join을 통한 연관 엔티티 조회 최적화
