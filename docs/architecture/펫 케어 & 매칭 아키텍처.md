# 펫 케어 & 매칭 아키텍처

## 📋 개요

펫 케어 & 매칭 도메인은 반려동물 돌봄이 필요한 사용자와 돌봄을 제공할 수 있는 사용자를 연결하는 핵심 도메인입니다. 요청 생성 → 지원 → 매칭 → 케어 수행 → 리뷰로 이어지는 전체 생애주기를 관리하며, 상호 리뷰 및 평점 시스템을 통해 펫시터 검증을 제공합니다.

## 🏗️ 시스템 아키텍처

### 전체 구조도

```mermaid
graph TB
    subgraph "Frontend"
        FE[React Frontend<br/>CareRequestList 컴포넌트]
    end
    
    subgraph "Backend API Layer"
        CRC[CareRequestController<br/>/api/care-requests]
        CRCC[CareRequestCommentController<br/>/api/care-request-comments]
        CRVC[CareReviewController<br/>/api/care-reviews]
        CC[ConversationController<br/>채팅 기반 매칭]
    end
    
    subgraph "Service Layer"
        CRS[CareRequestService<br/>요청 CRUD, 상태 관리]
        CRCS[CareRequestCommentService<br/>댓글 관리]
        CRVS[CareReviewService<br/>리뷰 관리, 평점 계산]
        CS[ConversationService<br/>채팅 기반 거래 확정]
        CRSCH[CareRequestScheduler<br/>자동 완료 처리]
    end
    
    subgraph "Data Layer"
        CRR[CareRequestRepository]
        CAR[CareApplicationRepository]
        CRCR[CareRequestCommentRepository]
        CRVR[CareReviewRepository]
        MySQL[(MySQL<br/>CareRequest<br/>CareApplication<br/>CareReview<br/>CareRequestComment)]
    end
    
    subgraph "External Integration"
        CHAT[Chat Domain<br/>채팅방 생성, 거래 확정]
        NOTI[Notification Domain<br/>알림 발송]
    end
    
    FE -->|요청 생성/조회| CRC
    FE -->|댓글 작성| CRCC
    FE -->|리뷰 작성| CRVC
    FE -->|채팅 시작| CC
    
    CRC --> CRS
    CRCC --> CRCS
    CRVC --> CRVS
    CC --> CS
    
    CRS --> CRR
    CRS --> CAR
    CRCS --> CRCR
    CRVS --> CRVR
    
    CS --> CAR
    CS --> CRR
    
    CRSCH --> CRR
    
    CRR --> MySQL
    CAR --> MySQL
    CRCR --> MySQL
    CRVR --> MySQL
    
    CRCS -->|알림| NOTI
    CS -->|알림| NOTI
    
    style CRS fill:#e1f5ff
    style CS fill:#fff4e1
    style CRVS fill:#ffe1f5
    style CRSCH fill:#e1ffe1
```

## 🔧 핵심 컴포넌트

### 1. CareRequestService (케어 요청 관리)

**역할**: 펫케어 요청 CRUD, 상태 관리, 검색

**주요 메서드**:
- `createCareRequest()`: 케어 요청 생성 (이메일 인증 필수)
- `getAllCareRequests()`: 전체 요청 조회 (상태/위치 필터링)
- `updateStatus()`: 상태 변경 (OPEN → IN_PROGRESS → COMPLETED → CANCELLED)
- `searchCareRequests()`: 키워드 검색

**핵심 로직**:

#### 상태 전이
```
OPEN → IN_PROGRESS → COMPLETED
  ↓
CANCELLED
```

#### 이메일 인증 필수
```java
if (user.getEmailVerified() == null || !user.getEmailVerified()) {
    throw new EmailVerificationRequiredException("펫케어 서비스 이용을 위해 이메일 인증이 필요합니다.");
}
```

#### 펫 정보 연결 (선택사항)
- 펫 소유자만 자신의 펫을 연결 가능
- 펫 정보는 선택사항 (null 허용)

### 2. ConversationService (채팅 기반 매칭)

**역할**: 채팅방을 통한 거래 확정 및 자동 매칭

**핵심 로직**: `confirmCareDeal()`

**매칭 프로세스**:
1. 펫케어 관련 채팅방 확인 (`RelatedType.CARE_REQUEST` 또는 `CARE_APPLICATION`)
2. 사용자의 거래 확정 처리 (`dealConfirmed`, `dealConfirmedAt` 설정)
3. 중복 확정 방지 체크
4. 양쪽 모두 확정 확인 (2명 참여자 모두 `dealConfirmed = true`)
5. 양쪽 모두 확정 시:
   - `CareRequest` 상태가 `OPEN`인 경우에만 처리
   - 제공자 찾기 (요청자가 아닌 참여자)
   - 기존 `CareApplication`이 있으면 승인, 없으면 생성 (`ACCEPTED` 상태)
   - `CareRequest` 상태를 `IN_PROGRESS`로 변경

**동시성 제어**: `@Transactional`로 트랜잭션 보장

**특징**:
- 채팅 도메인에서 `CareApplication` 생성/관리
- 양쪽 모두 거래 확정해야만 서비스 시작
- 자동 매칭 (수동 승인 불필요)

### 3. CareReviewService (리뷰 관리)

**역할**: 펫케어 리뷰 작성 및 평점 계산

**주요 메서드**:
- `createReview()`: 리뷰 작성 (요청자만 제공자에게 리뷰 작성 가능)
- `getAverageRating()`: 평균 평점 계산
- `getReviewsByReviewee()`: 특정 사용자에 대한 리뷰 목록

**핵심 로직**:

#### 리뷰 작성 조건
```java
// 1. CareApplication이 ACCEPTED 상태여야 함
if (careApplication.getStatus() != CareApplicationStatus.ACCEPTED) {
    throw new IllegalStateException("승인된 펫케어 서비스에만 리뷰를 작성할 수 있습니다.");
}

// 2. 중복 리뷰 방지
boolean alreadyReviewed = reviewRepository.existsByCareApplicationIdxAndReviewerIdx(
    dto.getCareApplicationId(), dto.getReviewerId());
if (alreadyReviewed) {
    throw new IllegalStateException("이미 해당 서비스에 리뷰를 작성하셨습니다.");
}

// 3. 요청자만 리뷰 작성 가능
if (!dto.getReviewerId().equals(requesterId)) {
    throw new IllegalArgumentException("요청자만 리뷰를 작성할 수 있습니다.");
}
```

#### 평점 계산
- 리뷰 평점의 평균값 계산
- 리뷰가 없으면 `null` 반환

### 4. CareRequestCommentService (댓글 관리)

**역할**: 펫케어 요청 댓글 관리

**주요 기능**:
- `SERVICE_PROVIDER` 역할만 댓글 작성 가능
- 파일 첨부 지원
- 댓글 작성 시 요청자에게 알림 발송
- Soft Delete 적용

### 5. CareRequestScheduler (자동 완료 처리)

**역할**: 날짜가 지난 요청 자동 완료

**스케줄러 설정**:
- 매 시간 정각 실행: `@Scheduled(cron = "0 0 * * * ?")`
- 매일 자정에도 실행: `@Scheduled(cron = "0 0 0 * * ?")`

**핵심 로직**:
```java
// 날짜가 지났고, OPEN 또는 IN_PROGRESS 상태인 요청 조회
List<CareRequest> expiredRequests = careRequestRepository
    .findByDateBeforeAndStatusIn(
        now,
        List.of(CareRequestStatus.OPEN, CareRequestStatus.IN_PROGRESS));

// 상태를 COMPLETED로 변경
for (CareRequest request : expiredRequests) {
    request.setStatus(CareRequestStatus.COMPLETED);
}
```

## 📊 데이터 흐름

### 1. 케어 요청 생성 및 매칭 흐름

```mermaid
sequenceDiagram
    participant Requester as 요청자
    participant Provider as 제공자
    participant Frontend
    participant CareRequestController
    participant CareRequestService
    participant ConversationService
    participant ChatDomain as 채팅 도메인
    participant MySQL
    
    Requester->>Frontend: 케어 요청 생성
    Frontend->>CareRequestController: POST /api/care-requests
    CareRequestController->>CareRequestService: createCareRequest()
    CareRequestService->>CareRequestService: 이메일 인증 확인
    CareRequestService->>MySQL: INSERT CareRequest (OPEN)
    MySQL-->>CareRequestService: 저장 완료
    CareRequestService-->>Frontend: CareRequestDTO 반환
    
    Provider->>Frontend: 요청 확인 및 채팅 시작
    Frontend->>ChatDomain: 채팅방 생성
    ChatDomain->>MySQL: INSERT Conversation
    
    Provider->>Frontend: 거래 확정 버튼 클릭
    Frontend->>ConversationService: confirmCareDeal()
    ConversationService->>ConversationService: dealConfirmed 설정
    
    Requester->>Frontend: 거래 확정 버튼 클릭
    Frontend->>ConversationService: confirmCareDeal()
    ConversationService->>ConversationService: 양쪽 모두 확정 확인
    
    ConversationService->>MySQL: SELECT CareApplication
    alt CareApplication 없음
        ConversationService->>MySQL: INSERT CareApplication (ACCEPTED)
    else CareApplication 있음
        ConversationService->>MySQL: UPDATE CareApplication (ACCEPTED)
    end
    
    ConversationService->>MySQL: UPDATE CareRequest (IN_PROGRESS)
    ConversationService-->>Frontend: 매칭 완료
```

### 2. 리뷰 작성 흐름

```mermaid
sequenceDiagram
    participant Requester as 요청자
    participant Frontend
    participant CareReviewController
    participant CareReviewService
    participant MySQL
    
    Requester->>Frontend: 리뷰 작성
    Frontend->>CareReviewController: POST /api/care-reviews
    CareReviewController->>CareReviewService: createReview()
    
    CareReviewService->>MySQL: SELECT CareApplication
    MySQL-->>CareReviewService: CareApplication (ACCEPTED)
    
    CareReviewService->>CareReviewService: 상태 확인 (ACCEPTED)
    CareReviewService->>MySQL: 중복 리뷰 확인
    MySQL-->>CareReviewService: 중복 없음
    
    CareReviewService->>CareReviewService: 요청자 확인
    CareReviewService->>MySQL: INSERT CareReview
    MySQL-->>CareReviewService: 저장 완료
    
    CareReviewService-->>Frontend: CareReviewDTO 반환
```

### 3. 자동 완료 처리 흐름

```mermaid
sequenceDiagram
    participant Scheduler as CareRequestScheduler
    participant MySQL
    
    Note over Scheduler: 매 시간 정각 실행
    Scheduler->>MySQL: SELECT * FROM CareRequest<br/>WHERE date < NOW()<br/>AND status IN (OPEN, IN_PROGRESS)
    MySQL-->>Scheduler: 만료된 요청 목록
    
    loop 각 요청마다
        Scheduler->>Scheduler: status = COMPLETED 설정
    end
    
    Scheduler->>MySQL: UPDATE CareRequest (일괄 저장)
    MySQL-->>Scheduler: 업데이트 완료
```

## 🎯 핵심 설계 전략

### 1. 채팅 기반 매칭 전략

**문제**: 전통적인 지원/승인 방식은 사용자 경험이 좋지 않음

**해결**: 채팅 기반 거래 확정 시스템
- 채팅방에서 조건 협의 후 양쪽 모두 확정
- 양쪽 모두 확정 시 자동 매칭
- 수동 승인 과정 제거로 UX 향상

**효과**:
- 사용자 간 직접 소통 가능
- 조건 협의 후 확정으로 신뢰도 향상
- 자동 매칭으로 프로세스 간소화

### 2. 상태 전이 전략

**문제**: 케어 요청의 생애주기를 명확하게 관리해야 함

**해결**: 상태 기반 전이 관리
- `OPEN`: 요청 생성, 지원 대기
- `IN_PROGRESS`: 매칭 완료, 케어 진행 중
- `COMPLETED`: 케어 완료
- `CANCELLED`: 취소

**상태 전이 규칙**:
- `OPEN` → `IN_PROGRESS`: 양쪽 모두 거래 확정 시
- `OPEN`/`IN_PROGRESS` → `COMPLETED`: 날짜 지나면 자동 또는 수동
- 모든 상태 → `CANCELLED`: 요청자 취소

### 3. 리뷰 시스템 전략

**문제**: 펫시터의 신뢰도를 검증해야 함

**해결**: 상호 리뷰 시스템
- 요청자만 제공자에게 리뷰 작성 가능
- 한 `CareApplication`당 1개의 리뷰만 작성 가능
- 평균 평점 계산으로 펫시터 검증

**효과**:
- 신뢰할 수 있는 펫시터 검증
- 리뷰 기반 평점 시스템
- 중복 리뷰 방지

### 4. 자동 완료 처리 전략

**문제**: 날짜가 지난 요청을 수동으로 완료 처리하는 것은 번거로움

**해결**: 스케줄러 기반 자동 완료
- 매 시간 정각 실행
- 매일 자정에도 실행 (더 정확한 처리)
- `OPEN` 또는 `IN_PROGRESS` 상태의 만료된 요청 자동 완료

**효과**:
- 사용자 개입 없이 자동 처리
- 데이터 일관성 유지
- 시스템 부하 최소화

### 5. 이메일 인증 필수 전략

**문제**: 신뢰할 수 있는 사용자만 서비스 이용해야 함

**해결**: 이메일 인증 필수
- 케어 요청 생성 시 이메일 인증 확인
- 미인증 사용자는 요청 생성 불가

**효과**:
- 신뢰할 수 있는 사용자만 서비스 이용
- 스팸 및 악의적 사용 방지

### 6. Soft Delete 전략

**문제**: 삭제된 데이터도 추적이 필요할 수 있음

**해결**: Soft Delete 적용
- `isDeleted` 플래그 사용
- `deletedAt` 타임스탬프 기록
- 실제 데이터는 유지

**효과**:
- 데이터 복구 가능
- 삭제 이력 추적
- 통계 및 분석 가능

## 🔄 도메인 간 연동

### 1. Chat 도메인 연동
- **용도**: 채팅방을 통한 거래 확정 및 매칭
- **방법**: `ConversationService.confirmCareDeal()` 호출
- **효과**: 채팅 기반 자동 매칭

### 2. Notification 도메인 연동
- **용도**: 댓글 작성 시 요청자에게 알림
- **방법**: `CareRequestCommentService`에서 알림 발송
- **효과**: 실시간 알림으로 사용자 참여도 향상

### 3. User 도메인 연동
- **용도**: 이메일 인증 확인, 펫 정보 연결
- **방법**: `Users.emailVerified` 필드 확인, `Pet` 엔티티 연결
- **효과**: 신뢰할 수 있는 사용자만 서비스 이용

## 📈 성능 최적화

### 1. DB 최적화

#### 인덱스 전략
```sql
-- 상태별 검색 인덱스
CREATE INDEX idx_care_request_status ON carerequest(status);
CREATE INDEX idx_care_request_date ON carerequest(date);

-- 삭제 여부 인덱스
CREATE INDEX idx_care_request_deleted ON carerequest(is_deleted);

-- 사용자별 조회 인덱스
CREATE INDEX idx_care_request_user ON carerequest(user_idx);

-- 날짜 기반 자동 완료 쿼리 최적화
CREATE INDEX idx_care_request_date_status ON carerequest(date, status);
```

**선정 이유**:
- 상태별 필터링이 빈번함
- 날짜 기반 자동 완료 쿼리 최적화
- 사용자별 조회가 자주 사용됨

### 2. 애플리케이션 레벨 최적화

#### 배치 처리
- 스케줄러에서 `saveAll()` 사용으로 일괄 저장
- N+1 문제 방지를 위한 `JOIN FETCH` 사용

#### 트랜잭션 관리
- `@Transactional`로 데이터 일관성 보장
- 읽기 전용 트랜잭션 (`@Transactional(readOnly = true)`) 사용

## 🔐 보안 고려사항

### 1. 권한 제어
- 케어 요청 생성: 이메일 인증 필수
- 댓글 작성: `SERVICE_PROVIDER` 역할만 가능
- 리뷰 작성: 요청자만 제공자에게 리뷰 작성 가능

### 2. 데이터 검증
- 펫 소유자 확인 (펫 정보 연결 시)
- 중복 리뷰 방지
- 상태 전이 규칙 검증

### 3. 입력 검증
- SQL Injection 방지 (JPA 사용)
- XSS 방지 (DTO 변환 시 이스케이프)

## 📝 주요 API 엔드포인트

### 케어 요청
```
GET /api/care-requests?status={status}&location={location}
→ List<CareRequestDTO>

POST /api/care-requests
→ CareRequestDTO

PUT /api/care-requests/{id}
→ CareRequestDTO

DELETE /api/care-requests/{id}
→ 204 No Content

PATCH /api/care-requests/{id}/status?status={status}
→ CareRequestDTO

GET /api/care-requests/search?keyword={keyword}
→ List<CareRequestDTO>
```

### 리뷰
```
POST /api/care-reviews
→ CareReviewDTO

GET /api/care-reviews/reviewee/{revieweeIdx}
→ List<CareReviewDTO>

GET /api/care-reviews/reviewer/{reviewerIdx}
→ List<CareReviewDTO>

GET /api/care-reviews/average/{revieweeIdx}
→ Double (평균 평점)
```

### 댓글
```
POST /api/care-request-comments
→ CareRequestCommentDTO

GET /api/care-request-comments/care-request/{careRequestIdx}
→ List<CareRequestCommentDTO>

DELETE /api/care-request-comments/{id}
→ 204 No Content
```

## 🎯 핵심 포인트 요약

### 1. 생애주기 관리
- **프로세스**: 요청 → 지원 → 매칭 → 케어 수행 → 리뷰
- **상태 전이**: OPEN → IN_PROGRESS → COMPLETED
- **자동 완료**: 날짜 지난 요청 자동 완료 처리

### 2. 채팅 기반 매칭
- **방식**: 채팅방에서 조건 협의 후 양쪽 모두 확정
- **자동 매칭**: 양쪽 모두 확정 시 자동으로 `CareApplication` 생성 및 승인
- **효과**: UX 향상, 신뢰도 향상

### 3. 리뷰 시스템
- **작성자**: 요청자만 제공자에게 리뷰 작성 가능
- **중복 방지**: 한 `CareApplication`당 1개의 리뷰만 작성 가능
- **평점 계산**: 평균 평점으로 펫시터 검증

### 4. 신뢰 시스템
- **이메일 인증**: 케어 요청 생성 시 필수
- **상호 리뷰**: 요청자가 제공자에게 리뷰 작성
- **평점 시스템**: 평균 평점으로 펫시터 검증

### 5. 자동화
- **자동 완료**: 스케줄러로 날짜 지난 요청 자동 완료
- **자동 매칭**: 양쪽 모두 거래 확정 시 자동 매칭
- **알림**: 댓글 작성 시 자동 알림 발송

### 6. 확장성
- **상태 관리**: 명확한 상태 전이 규칙
- **도메인 분리**: Chat, Notification 도메인과의 명확한 분리
- **유연한 설계**: 펫 정보 연결 선택사항, 위치 필터링 확장 가능
