# 이메일 인증 시스템 아키텍처

## 📋 개요

Petory 서비스에서 사용자 신뢰도 향상과 악용 방지를 위한 **이메일 인증 시스템**입니다.
단일 통합 시스템으로 구현하여 다양한 용도에서 재사용 가능하며, 서비스 레벨에서 세밀한 권한 제어를 제공합니다.

---

## 🎯 문제 정의 및 배경

### 왜 이메일 인증이 필요한가?

1. **보안 강화**: 비밀번호 변경 등 민감한 작업 전 본인 확인
2. **서비스 품질 향상**: 펫케어, 모임 등 신뢰가 필요한 서비스의 악용 방지
3. **책임 있는 행동**: 수정/삭제 등 책임이 따르는 행위에 대한 최소 조건
4. **스팸/부정 계정 방지**: 가짜 이메일로 가입한 계정 차단

### 문제점

- 각 기능별로 별도의 인증 시스템을 구현하면 코드 중복 발생
- 인증 로직이 분산되어 유지보수 어려움
- 일관성 없는 권한 정책으로 사용자 혼란

---

## 🏗️ 핵심 설계 원칙

### ❌ 잘못된 접근

각 케이스별로 별도의 인증 시스템을 구현:
- 비밀번호 변경용 이메일 인증
- 펫케어용 이메일 인증
- 모임용 이메일 인증
- 리뷰용 이메일 인증

**문제점**:
- 코드 중복
- 유지보수 어려움
- 일관성 부족

### ✅ 올바른 접근

**단일 이메일 인증 시스템 + 용도 분리 + 서비스 레벨 권한 체크**

**핵심 원칙**:
> **"이메일 인증은 '고급 기능 접근용'이 아니라 '책임 있는 행동을 할 수 있는 최소 조건'이다."**

---

## 🔧 구현 전략

### 1. 단일 인증 토큰 생성

이메일 인증 링크에 포함된 토큰은 하나의 표준 형식으로 생성합니다.

```java
// JWT 기반 인증 토큰 생성
String token = jwtUtil.createEmailVerificationToken(userId, purpose);
// 형식: {userId, purpose, expiration}
```

### 2. 용도(Purpose) 분리

토큰에 `purpose` 파라미터를 포함하여 용도를 구분합니다.

```java
public enum EmailVerificationPurpose {
    PASSWORD_RESET,      // 비밀번호 변경
    PET_CARE,            // 펫케어 서비스
    MEETUP,              // 모임 서비스
    LOCATION_REVIEW,     // 주변서비스 리뷰
    BOARD_EDIT,          // 게시글 수정/삭제
    COMMENT_EDIT,       // 댓글 수정/삭제
    MISSING_PET         // 실종 제보 작성/수정/삭제
}
```

### 3. 서비스 레벨 권한 체크

각 서비스에서 `emailVerified` 필드를 확인하여 권한을 체크합니다.

```java
// 예시: 펫케어 요청 작성 시
public CareRequestDTO createCareRequest(CareRequestDTO dto) {
    String userId = getCurrentUserId();
    Users user = usersRepository.findByIdString(userId).orElseThrow();
    
    // 이메일 인증 확인
    if (user.getEmailVerified() == null || !user.getEmailVerified()) {
        throw new EmailVerificationRequiredException("이메일 인증이 필요합니다.");
    }
    
    // 펫케어 요청 생성 로직...
}
```

### 4. 통합 인증 처리

인증 링크 클릭 시 `emailVerified = true`로 업데이트합니다. (용도 무관)

```java
@Transactional
public void verifyEmail(String token) {
    // 토큰 검증 및 사용자 ID, purpose 추출
    String userId = jwtUtil.extractUserIdFromEmailToken(token);
    EmailVerificationPurpose purpose = jwtUtil.extractPurposeFromEmailToken(token);
    
    Users user = usersRepository.findByIdString(userId).orElseThrow();
    
    // 이메일 인증 완료 (용도 무관, 단일 인증 상태로 업데이트)
    user.setEmailVerified(true);
    usersRepository.save(user);
    
    // 용도별 후속 처리 (필요 시)
    switch (purpose) {
        case PASSWORD_RESET -> {
            // 비밀번호 재설정 페이지로 리다이렉트
        }
        case PET_CARE -> {
            // 펫케어 서비스 페이지로 리다이렉트
        }
        // ...
    }
}
```

---

## 🔐 권한 정책

### 1단계: 로그인만으로 허용 (기본 커뮤니티 활동)

**목적**: 유입용, 참여 유도용

- ✅ 모든 조회 기능
- ✅ 게시글 작성
- ✅ 댓글 작성
- ✅ 일반 커뮤니티 질문글

### 2단계: 이메일 인증 필수 (책임 있는 행동)

**목적**: 책임 발생 + 악용 가능성 있는 행위

- ✅ 게시글 수정/삭제
- ✅ 댓글 수정/삭제
- ✅ 실종 제보 작성/수정/삭제
- ✅ 리뷰 작성 (펫케어, 주변서비스)
- ✅ 모임 생성/참여
- ✅ 펫케어 요청/지원
- ✅ 비밀번호 변경

---

## 📡 API 엔드포인트

### 이메일 인증 메일 발송

```http
POST /api/users/email/verify
Content-Type: application/json

{
  "purpose": "PET_CARE"
}
```

**설명**: 
- 현재 로그인한 사용자에게 이메일 인증 메일을 발송합니다.
- `purpose` 파라미터로 용도를 지정합니다.

**응답**:
```json
{
  "success": true,
  "message": "이메일 인증 메일이 발송되었습니다."
}
```

### 이메일 인증 처리

```http
GET /api/users/email/verify/{token}
```

**설명**: 
- 이메일 인증 링크를 클릭하면 호출됩니다.
- 토큰을 검증하고 `emailVerified = true`로 업데이트합니다.
- 용도에 따라 적절한 페이지로 리다이렉트합니다.

**리다이렉트 예시**:
- `PASSWORD_RESET` → 비밀번호 재설정 페이지
- `PET_CARE` → 펫케어 서비스 페이지
- `MEETUP` → 모임 서비스 페이지
- 기타 → 메인 페이지

---

## 🔄 인증 플로우

### 일반 회원가입 사용자

```
1. 회원가입
   ↓
2. 이메일 인증 메일 발송 (자동)
   ↓
3. 사용자가 이메일 링크 클릭
   ↓
4. 토큰 검증 및 emailVerified = true 업데이트
   ↓
5. 인증 완료
```

### 소셜 로그인 사용자

```
1. 소셜 로그인 (Google/Naver)
   ↓
2. emailVerified 자동 설정
   - Google: email_verified 값 사용
   - Naver: 기본 true로 설정
   ↓
3. 인증 완료 (추가 작업 불필요)
```

### 서비스 이용 시

```
1. 사용자가 서비스 접근 시도
   ↓
2. 서비스 레벨에서 emailVerified 확인
   ↓
3-1. 인증 완료 → 서비스 이용 가능
3-2. 인증 미완료 → 모달 표시 → 이메일 인증 페이지로 리다이렉트
```

---

## 💻 기술적 세부사항

### 이메일 발송 (비동기 처리)

```java
@Service
@RequiredArgsConstructor
public class EmailService {
    
    private final JavaMailSender mailSender;
    
    @Async
    public void sendVerificationEmail(String email, String token, EmailVerificationPurpose purpose) {
        // 이메일 발송 로직
        // 비동기 처리로 사용자 응답 지연 방지
    }
}
```

### 토큰 생성 및 검증

```java
// JWT 유틸 확장
public String createEmailVerificationToken(String userId, EmailVerificationPurpose purpose) {
    // JWT 토큰 생성 (userId, purpose 포함)
    // 만료 시간: 24시간
}

public String extractUserIdFromEmailToken(String token) {
    // 토큰에서 userId 추출
}

public EmailVerificationPurpose extractPurposeFromEmailToken(String token) {
    // 토큰에서 purpose 추출
}
```

### 예외 처리

```java
public class EmailVerificationRequiredException extends RuntimeException {
    public EmailVerificationRequiredException(String message) {
        super(message);
    }
}
```

---

## 🚀 확장성 고려사항

### 향후 추가 가능한 용도

- 계정 복구
- 2단계 인증 (2FA)
- 중요 알림 수신 동의

### 향후 대체 가능한 인증 방식

- SMS 인증
- 본인인증 (휴대폰 인증)
- 생체 인증

**확장 전략**: 
- 현재는 이메일 인증만 지원하지만, 향후 다른 인증 방식 추가 시 `EmailVerificationPurpose`와 유사한 방식으로 확장 가능
- 서비스 레벨 권한 체크는 `emailVerified` 필드 대신 `isVerified()` 메서드로 추상화하여 다양한 인증 방식 지원 가능

---

## 📊 데이터베이스 스키마

### Users 테이블

```sql
ALTER TABLE users
ADD COLUMN email_verified BOOLEAN DEFAULT FALSE 
COMMENT '이메일 인증 여부 (구글: email_verified, 네이버: 기본 true)';

CREATE INDEX idx_users_email_verified ON users(email_verified);
```

**설명**:
- 단일 필드로 모든 용도의 인증 상태 관리
- 인증 완료 시 `true`로 업데이트 (용도 무관)
- 소셜 로그인 사용자는 자동으로 `true` 설정

---

## 🎨 프론트엔드 구현

### 이메일 인증 모달

```javascript
// EmailVerificationModal.js
const EmailVerificationModal = ({ purpose, onClose }) => {
  const handleSendEmail = async () => {
    await userProfileApi.sendVerificationEmail(purpose);
    // 성공 메시지 표시
  };
  
  return (
    <Modal>
      <Title>이메일 인증이 필요합니다</Title>
      <Message>이 기능을 이용하려면 이메일 인증이 필요합니다.</Message>
      <Button onClick={handleSendEmail}>인증 메일 발송</Button>
    </Modal>
  );
};
```

### 서비스 접근 시 체크

```javascript
// 예시: 펫케어 요청 작성 시
const handleCreateCareRequest = async () => {
  if (!user.emailVerified) {
    setShowEmailVerificationModal(true);
    return;
  }
  
  // 펫케어 요청 작성 로직
};
```

---

## ✅ 장점

1. **코드 재사용**: 단일 시스템으로 모든 용도 지원
2. **유지보수 용이**: 인증 로직이 한 곳에 집중
3. **일관성**: 모든 서비스에서 동일한 인증 방식 사용
4. **확장성**: 새로운 용도 추가 시 enum만 확장
5. **사용자 경험**: 단계적 진입으로 자연스러운 전환

---

## 📝 요약

이메일 인증 시스템은 **단일 통합 시스템**으로 구현하여:
- 다양한 용도에서 재사용 가능
- 서비스 레벨에서 세밀한 권한 제어
- 사용자 경험을 고려한 단계적 진입 정책

**핵심 원칙**: 
> "이메일 인증은 '고급 기능 접근용'이 아니라 '책임 있는 행동을 할 수 있는 최소 조건'이다."

