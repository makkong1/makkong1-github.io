# Petory 프로젝트 기술 면접 질문 리스트

> **프로젝트**: 반려동물 통합 플랫폼 Petory  
> **기술 스택**: Spring Boot 3.x, Java 17, JPA, MySQL, Redis, React 19, JWT, WebSocket, SSE

---

## 📋 목차

1. [프로젝트 개요 및 아키텍처](#1-프로젝트-개요-및-아키텍처)
2. [Spring Boot & Java](#2-spring-boot--java)
3. [JPA & 데이터베이스](#3-jpa--데이터베이스)
4. [성능 최적화](#4-성능-최적화)
5. [동시성 제어](#5-동시성-제어)
6. [보안 & 인증](#6-보안--인증)
7. [실시간 통신](#7-실시간-통신)
8. [프론트엔드](#8-프론트엔드)
9. [트러블슈팅 & 문제 해결](#9-트러블슈팅--문제-해결)
10. [시스템 설계 & 확장성](#10-시스템-설계--확장성)

---

## 1. 프로젝트 개요 및 아키텍처

### Q1-1. Petory 프로젝트를 간단히 소개해주세요.
**답변 포인트:**
- 반려동물 통합 플랫폼으로 커뮤니티, 펫케어 매칭, 실종 동물 찾기, 위치 기반 서비스, 오프라인 모임 기능 제공
- 도메인 주도 설계(DDD)와 레이어드 아키텍처 적용
- 11개 도메인으로 구성 (User, Board, Care, Location, MissingPet, Meetup, Chat, Notification, Report, Statistics, File)

### Q1-2. 프로젝트에서 도메인 주도 설계(DDD)를 어떻게 적용했나요?
**답변 포인트:**
- 도메인별 패키지 구조로 응집도 향상
- 각 도메인은 독립적인 패키지로 구성 (user, board, care 등)
- 명확한 도메인 경계와 책임 분리
- 도메인 간 느슨한 결합을 위한 이벤트 기반 연동

### Q1-3. 레이어드 아키텍처의 각 레이어 역할을 설명해주세요.
**답변 포인트:**
- **Controller Layer**: HTTP 요청/응답 처리, REST API, WebSocket, SSE 엔드포인트
- **Service Layer**: 비즈니스 로직 처리, 트랜잭션 관리
- **Repository Layer**: 데이터 액세스 추상화 (JPA Repository)
- **Entity Layer**: 도메인 모델 표현

### Q1-4. 프로젝트의 핵심 성과를 설명해주세요.
**답변 포인트:**
- **Board 도메인**: 쿼리 수 301개 → 3개 (99% 감소), 실행 시간 745ms → 30ms (24.83배 개선)
- **Location 도메인**: 조회 데이터 22,699개 → 1,026개 (95.5% 감소)
- **User 도메인**: 로그인 쿼리 21개 → 4개 (80.95% 감소)

---

## 2. Spring Boot & Java

### Q2-1. Spring Boot의 주요 특징과 이 프로젝트에서 활용한 부분을 설명해주세요.
**답변 포인트:**
- Auto Configuration으로 설정 자동화
- Spring Data JPA로 데이터 액세스 추상화
- Spring Security로 인증/인가 처리
- Spring Scheduler로 주기적 작업 자동화
- Spring Cache로 캐싱 전략 구현

### Q2-2. @Transactional 어노테이션의 동작 원리와 격리 수준을 설명해주세요.
**답변 포인트:**
- AOP 기반으로 트랜잭션 관리
- 기본 격리 수준: READ_COMMITTED
- 전파 속성: REQUIRED (기본값)
- 읽기 전용 트랜잭션: @Transactional(readOnly = true)

### Q2-3. Spring Security의 필터 체인을 설명해주세요.
**답변 포인트:**
- JwtAuthenticationFilter: JWT 토큰 검증
- SecurityConfig: 인증/인가 설정
- 필터 순서와 역할
- 공개 API와 보호된 API 구분

### Q2-4. Spring Scheduler를 어떤 용도로 사용했나요?
**답변 포인트:**
- 일별 통계 집계 (Statistics Scheduler)
- 인기글 스냅샷 생성 (Popularity Scheduler)
- 제재 자동 해제 (Sanction Scheduler)
- 케어 요청 만료 처리 (Care Scheduler)

### Q2-5. Java 17의 주요 특징과 프로젝트에서 활용한 부분은?
**답변 포인트:**
- Records, Pattern Matching, Sealed Classes
- Stream API 활용
- Optional 활용
- Lambda 표현식

---

## 3. JPA & 데이터베이스

### Q3-1. N+1 문제가 무엇이고, 어떻게 해결했나요?
**답변 포인트:**
- **문제**: 연관 엔티티를 개별 쿼리로 조회하는 문제
- **해결 방법**:
  - Fetch Join 활용: `JOIN FETCH`로 한 번에 조회
  - 배치 조회: IN 절을 활용한 집계 쿼리
  - 예시: Board 도메인에서 301개 쿼리 → 3개 쿼리로 감소

### Q3-2. Fetch Join과 일반 Join의 차이를 설명해주세요.
**답변 포인트:**
- **Fetch Join**: 연관 엔티티를 즉시 로딩하여 N+1 문제 해결
- **일반 Join**: 연관 엔티티를 조회하지 않음 (지연 로딩)
- Fetch Join은 SELECT 절에 연관 엔티티를 포함

### Q3-3. JPA의 지연 로딩(Lazy Loading)과 즉시 로딩(Eager Loading)의 차이는?
**답변 포인트:**
- **Lazy Loading**: 필요할 때만 조회 (기본값)
- **Eager Loading**: 항상 함께 조회 (N+1 문제 발생 가능)
- Fetch Join으로 필요 시에만 즉시 로딩

### Q3-4. 데이터베이스 인덱스 전략을 설명해주세요.
**답변 포인트:**
- 자주 조회되는 컬럼에 인덱스 생성 (id, email, nickname 등)
- UNIQUE 제약조건으로 중복 방지
- 복합 인덱스 활용
- FULLTEXT 인덱스로 검색 성능 향상

### Q3-5. 쿼리 최적화를 위해 어떤 방법을 사용했나요?
**답변 포인트:**
- 배치 조회로 IN 절 활용
- Fetch Join으로 N+1 문제 해결
- 스냅샷 패턴으로 사전 집계
- 인덱스 전략 수립

### Q3-6. MySQL의 ST_Distance_Sphere 함수를 어떻게 활용했나요?
**답변 포인트:**
- 위치 기반 거리 계산
- 사용자 위치 기준 10km 반경 검색
- Location 도메인에서 초기 로드 성능 개선 (95.5% 데이터 감소)

---

## 4. 성능 최적화

### Q4-1. Board 도메인에서 301개 쿼리를 3개로 줄인 방법을 설명해주세요.
**답변 포인트:**
- **문제**: 게시글 목록 조회 시 작성자, 반응 정보, 첨부파일을 개별 쿼리로 조회
- **해결**:
  1. Fetch Join으로 작성자 정보 함께 조회
  2. 배치 조회로 반응 정보 IN 절 집계
  3. 배치 조회로 첨부파일 정보 조회
- **결과**: 301개 → 3개 쿼리 (99% 감소)

### Q4-2. 인기글 스냅샷 패턴을 설명해주세요.
**답변 포인트:**
- 복잡한 계산 결과를 미리 생성하여 저장
- 스케줄러로 주기적으로 스냅샷 생성
- 조회 시 복잡한 계산 없이 스냅샷 조회
- 실시간성과 성능의 트레이드오프

### Q4-3. Redis 캐싱 전략을 설명해주세요.
**답변 포인트:**
- 알림 최신 50개를 Redis에 저장 (TTL 24시간)
- 인기글 스냅샷 캐싱
- 위치 서비스 데이터 캐싱
- Spring Cache 어노테이션 활용 (@Cacheable, @CacheEvict)

### Q4-4. Location 도메인에서 초기 로드 성능을 어떻게 개선했나요?
**답변 포인트:**
- **문제**: 초기 로드 시 전체 데이터(22,699개) 조회
- **해결**: 사용자 위치 기반 10km 반경 검색
- **결과**: 22,699개 → 1,026개 (95.5% 감소)

### Q4-5. 배치 조회(Batch Query)를 어떻게 구현했나요?
**답변 포인트:**
- IN 절을 활용한 집계 쿼리
- 500개 단위로 배치 처리하여 IN 절 크기 제한
- 예시: 반응 정보 배치 조회로 100개 쿼리 → 1개 쿼리

---

## 5. 동시성 제어

### Q5-1. 동시성 문제가 발생할 수 있는 시나리오를 설명해주세요.
**답변 포인트:**
- 여러 관리자가 동시에 같은 사용자에게 경고 부여
- 같은 소셜 계정으로 동시에 여러 번 로그인 시도
- 모임 참여 시 인원 초과 문제
- 펫케어 요청 확정 시 중복 확정 문제

### Q5-2. Lost Update 문제를 어떻게 해결했나요?
**답변 포인트:**
- **문제**: 여러 스레드가 동시에 같은 값을 읽고 증가시키면 값이 누락됨
- **해결**: DB 레벨에서 원자적 증가 쿼리 사용
  ```java
  @Modifying
  @Query("UPDATE Users u SET u.warningCount = u.warningCount + 1 WHERE u.idx = :userId")
  void incrementWarningCount(@Param("userId") Long userId);
  ```

### Q5-3. 소셜 로그인 동시성 문제를 어떻게 해결했나요?
**답변 포인트:**
- **문제**: 같은 소셜 계정으로 동시에 여러 번 로그인 시도 시 중복 계정 생성
- **해결**: 
  - DB UNIQUE 제약조건 (Users.email, SocialUser.provider + providerId)
  - 트랜잭션 격리 수준 활용
  - 중복 생성 시도 시 DB 제약조건 위반 예외 발생

### Q5-4. 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)의 차이는?
**답변 포인트:**
- **낙관적 락**: @Version 필드로 버전 관리, 충돌 시 예외 발생
- **비관적 락**: DB 레벨에서 락 획득, SELECT FOR UPDATE
- 프로젝트에서는 주로 DB 제약조건과 원자적 쿼리 활용

### Q5-5. 모임 참여 시 동시성 문제를 어떻게 해결했나요?
**답변 포인트:**
- 트랜잭션 내에서 인원 수 확인 및 증가
- DB 제약조건으로 최대 인원 초과 방지
- Race Condition 방지를 위한 원자적 연산

---

## 6. 보안 & 인증

### Q6-1. JWT 토큰 기반 인증 방식을 설명해주세요.
**답변 포인트:**
- Access Token (15분) + Refresh Token (1일)
- Access Token 만료 시 Refresh Token으로 갱신
- JwtAuthenticationFilter에서 토큰 검증
- 토큰에 사용자 정보 포함 (idx, role 등)

### Q6-2. OAuth2 소셜 로그인을 어떻게 구현했나요?
**답변 포인트:**
- Google, Naver 지원
- Spring Security OAuth2 Client 활용
- Provider별 OAuth2UserService에서 표준화
- 기존 사용자 자동 연결, 신규 사용자 자동 회원가입

### Q6-3. 이메일 인증 시스템을 설명해주세요.
**답변 포인트:**
- 단일 이메일 인증 시스템
- Redis에 임시 인증 정보 저장
- 이메일 인증 완료 후 서비스 이용 가능
- 소셜 로그인 시 자동 인증 완료

### Q6-4. 비밀번호 암호화 방식을 설명해주세요.
**답변 포인트:**
- BCryptPasswordEncoder 사용
- Salt 자동 생성
- 단방향 해시 함수

### Q6-5. 역할 기반 접근 제어(RBAC)를 어떻게 구현했나요?
**답변 포인트:**
- Role: USER, ADMIN, SERVICE_PROVIDER, MASTER
- @PreAuthorize 어노테이션으로 권한 체크
- SecurityConfig에서 경로별 권한 설정

### Q6-6. SQL Injection과 XSS 공격을 어떻게 방지했나요?
**답변 포인트:**
- **SQL Injection**: JPA 사용으로 자동 방지 (PreparedStatement)
- **XSS**: DTO 변환 시 이스케이프 처리
- 경로 정규화로 Directory Traversal 공격 방지

---

## 7. 실시간 통신

### Q7-1. WebSocket과 SSE의 차이를 설명해주세요.
**답변 포인트:**
- **WebSocket**: 양방향 통신, STOMP 프로토콜 사용, 채팅에 활용
- **SSE**: 서버 → 클라이언트 단방향, EventSource API, 알림에 활용
- 프로젝트에서 WebSocket은 채팅, SSE는 알림에 사용

### Q7-2. WebSocket(STOMP) 기반 채팅 시스템을 설명해주세요.
**답변 포인트:**
- STOMP 프로토콜로 메시지 브로커 활용
- 1:1 채팅, 그룹 채팅 지원
- 펫케어/모임 생성 시 채팅방 자동 연동
- 읽음 상태 관리

### Q7-3. SSE 기반 알림 시스템을 설명해주세요.
**답변 포인트:**
- 이중 저장소 전략: Redis + MySQL
- Redis에 최신 50개 알림 저장 (TTL 24시간)
- SSE로 실시간 알림 푸시
- 읽음 처리 및 알림 이력 관리

### Q7-4. 채팅 읽음 상태를 어떻게 최적화했나요?
**답변 포인트:**
- 배치 조회로 읽음 상태 정보 한 번에 조회
- Redis 캐싱 활용
- N+1 문제 해결

---

## 8. 프론트엔드

### Q8-1. React의 주요 특징과 프로젝트에서 활용한 부분은?
**답변 포인트:**
- 컴포넌트 기반 아키텍처
- React Router로 라우팅
- Styled-components로 스타일링
- Recharts로 차트 시각화

### Q8-2. 상태 관리 방식을 설명해주세요.
**답변 포인트:**
- Context API 또는 로컬 상태 관리
- JWT 토큰을 로컬 스토리지에 저장
- Axios로 API 호출

### Q8-3. 성능 최적화를 위해 어떤 방법을 사용했나요?
**답변 포인트:**
- useMemo, useCallback으로 메모이제이션
- 지연 로딩(Lazy Loading)
- 위치 기반 초기 로드로 데이터 양 감소

---

## 9. 트러블슈팅 & 문제 해결

### Q9-1. 로그인 시 N+1 문제를 어떻게 해결했나요?
**답변 포인트:**
- **문제**: 로그인 시 채팅방 목록 조회 과정에서 N+1 문제 발생
- **해결**: 배치 조회 패턴, Fetch Join, 최신 메시지만 조회
- **결과**: 쿼리 수 21개 → 4개 (80.95% 감소)

### Q9-2. 제재 시스템 동시성 문제를 어떻게 해결했나요?
**답변 포인트:**
- **문제**: 여러 관리자가 동시에 경고 부여 시 Lost Update 발생
- **해결**: DB 레벨에서 원자적 증가 쿼리 사용
- **효과**: 경고 횟수가 정확하게 증가하며, 자동 이용제한이 정확히 한 번만 적용

### Q9-3. 펫케어 요청 확정 시 Race Condition을 어떻게 해결했나요?
**답변 포인트:**
- 트랜잭션 내에서 상태 확인 및 변경
- 원자적 연산으로 중복 확정 방지
- DB 제약조건 활용

### Q9-4. 모임 참여 시 인원 초과 문제를 어떻게 해결했나요?
**답변 포인트:**
- 트랜잭션 내에서 인원 수 확인 및 증가
- DB 제약조건으로 최대 인원 초과 방지
- Race Condition 방지

---

## 10. 시스템 설계 & 확장성

### Q10-1. 시스템을 확장하려면 어떻게 해야 할까요?
**답변 포인트:**
- 마이크로서비스 전환: 도메인별 독립 배포
- API Gateway 도입: 중앙 집중형 라우팅
- 메시지 큐 도입: 비동기 작업 처리
- 읽기 전용 레플리카: 읽기 작업 분산

### Q10-2. 캐싱 전략을 어떻게 설계했나요?
**답변 포인트:**
- Redis 캐싱: 알림, 인기글, 위치 서비스
- Spring Cache: 자주 조회되는 데이터
- TTL 관리: 데이터 특성에 따른 만료 시간 설정
- 캐시 무효화 전략: @CacheEvict 활용

### Q10-3. 대용량 트래픽을 처리하기 위한 전략은?
**답변 포인트:**
- 읽기 전용 레플리카로 읽기 작업 분산
- CDN 도입으로 정적 리소스 배포
- 쿼리 최적화 및 인덱싱
- 캐싱 전략 강화

### Q10-4. 모니터링과 로깅 전략은?
**답변 포인트:**
- 애플리케이션 모니터링: Prometheus + Grafana
- 로그 집계: ELK Stack
- 분산 추적: Zipkin 또는 Jaeger
- 성능 프로파일링

### Q10-5. 데이터베이스 부하를 줄이기 위한 전략은?
**답변 포인트:**
- 인덱스 전략 수립
- 쿼리 최적화 (N+1 문제 해결)
- 캐싱 활용
- 읽기 전용 레플리카
- 스냅샷 패턴으로 사전 집계

---

## 🎯 핵심 키워드 정리

### 아키텍처
- 도메인 주도 설계 (DDD)
- 레이어드 아키텍처
- 이벤트 기반 연동

### 성능 최적화
- N+1 문제 해결
- Fetch Join
- 배치 조회
- 스냅샷 패턴
- Redis 캐싱

### 동시성 제어
- 원자적 증가 쿼리
- DB 제약조건
- 트랜잭션 관리
- 낙관적/비관적 락

### 보안
- JWT 인증
- OAuth2 소셜 로그인
- BCrypt 암호화
- 역할 기반 접근 제어

### 실시간 통신
- WebSocket (STOMP)
- Server-Sent Events (SSE)
- 이중 저장소 전략

---

## 📝 면접 팁

1. **구체적인 수치 제시**: "301개 쿼리 → 3개 쿼리 (99% 감소)"처럼 구체적인 성과 제시
2. **문제 → 해결 → 결과 구조**: 문제 상황을 먼저 설명하고, 해결 방법, 최종 결과 순서로 설명
3. **코드 예시 준비**: 주요 해결 방법에 대한 코드 예시 준비
4. **트레이드오프 설명**: 성능과 실시간성, 일관성과 가용성 등 트레이드오프 고려 사항 설명
5. **확장성 고려**: 현재 구현의 한계와 향후 개선 방향 제시

---

**작성일**: 2024년  
**프로젝트**: Petory - 반려동물 통합 플랫폼
